# ============================================================================
# This code contains proprietary source code from NEHONIX
# Copyright Â© 2025 NEHONIX - www.nehonix.com
# Licensed under NEHONIX Open Source License (NOSL) v1.0
# ============================================================================
# XyNginC - SSL/TLS Virtual Host Configuration Template
# ============================================================================
# HTTPS configuration for secure domain hosting
# Optimized for A+ SSL Labs rating, performance, and modern security standards
#
# Usage:
#   Replace template variables while running the script:
#   - {{DOMAIN_NAME}}     : Your domain (e.g., example.com, www.example.com)
#   - {{BACKEND_HOST}}    : Backend server hostname/IP (e.g., localhost, 127.0.0.1)
#   - {{BACKEND_PORT}}    : Backend application port (e.g., 3000, 8080)
#   - {{MAX_BODY_SIZE}}   : Maximum upload size (e.g., 10M, 50M, 100M)
#
# Requirements:
#   - nginx-module-headers-more for custom Server header manipulation
#   - Install: sudo apt install nginx-module-headers-more
#   - Load in main nginx.conf: load_module modules/ngx_http_headers_more_filter_module.so;
#   - SSL certificates managed by Let's Encrypt via certbot
#   - Install certbot: sudo apt install certbot python3-certbot-nginx
#   - Obtain certificate: sudo certbot certonly --webroot -w /var/www/letsencrypt -d {{DOMAIN_NAME}}
#
# Security Features:
#   - TLS 1.2 and 1.3 only (no outdated protocols)
#   - Modern cipher suites with forward secrecy
#   - HSTS with preload for maximum security
#   - OCSP stapling for certificate validation
#   - Comprehensive security headers
#   - Perfect Forward Secrecy (PFS)
#
# Version: 2.0
# Last Updated: 2025-01-18
# ============================================================================

# ============================================================================
# HTTP to HTTPS Redirect (Port 80)
# ============================================================================
# All HTTP traffic is permanently redirected to HTTPS for security
# Exception: Let's Encrypt ACME challenge for certificate renewal

server {
    # Listen on standard HTTP port for both IPv4 and IPv6
    listen 80;
    listen [::]:80;
    
    # Server name - replace with actual domain
    server_name {{DOMAIN_NAME}};

    # ------------------------------------------------------------------------
    # Security Configuration (HTTP)
    # ------------------------------------------------------------------------

    # Hide nginx version number to prevent information disclosure
    server_tokens off;

    # Custom Server header - replace nginx signature
    more_clear_headers Server;
    more_set_headers "Server: NEHONIX/XNCP";

    # ------------------------------------------------------------------------
    # Logging Configuration (HTTP Redirects)
    # ------------------------------------------------------------------------

    # Log HTTP requests before redirecting to HTTPS
    # Useful for monitoring and detecting mixed-content issues
    access_log /var/log/nginx/{{DOMAIN_NAME}}_http_access.log combined;
    error_log  /var/log/nginx/{{DOMAIN_NAME}}_http_error.log  warn;

    # ------------------------------------------------------------------------
    # Let's Encrypt ACME Challenge
    # ------------------------------------------------------------------------

    # ACME challenge location for certificate issuance and renewal
    # Certbot places validation files here during certificate operations
    # ^~ prefix ensures this location takes priority over regex locations
    location ^~ /.well-known/acme-challenge/ {
        root /var/www/letsencrypt;
        default_type "text/plain";
        try_files $uri =404;
    }

    # ------------------------------------------------------------------------
    # Custom Error Pages (HTTP)
    # ------------------------------------------------------------------------

    # Handle errors that may occur during HTTP -> HTTPS redirect
    error_page 404 /errors/404.html;
    error_page 301 /errors/301.html;
    error_page 502 503 504 /error.html;

    location = /errors/404.html {
        root /var/www/html;
        internal;
        default_type text/html;
    }

    location = /errors/301.html {
        root /var/www/html;
        internal;
        default_type text/html;
    }

    location = /error.html {
        root /var/www/html/errors;
        internal;
        default_type text/html;
    }

    # ------------------------------------------------------------------------
    # Permanent HTTPS Redirect
    # ------------------------------------------------------------------------

    # Redirect all HTTP traffic to HTTPS (301 Permanent)
    # Preserves URI and query parameters
    # $host preserves original hostname (important for multi-domain setups)
    location / {
        return 301 https://$host$request_uri;
    }
}

# ============================================================================
# HTTPS Virtual Host (Port 443)
# ============================================================================
# Main secure server configuration with TLS/SSL encryption

server {
    # Listen on HTTPS port with SSL and HTTP/2 support
    # HTTP/2 provides multiplexing, header compression, and server push
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    
    # Server name - replace with actual domain
    server_name {{DOMAIN_NAME}};

    # ------------------------------------------------------------------------
    # Security Configuration (HTTPS)
    # ------------------------------------------------------------------------

    # Hide nginx version number
    server_tokens off;

    # Custom Server header for HTTPS
    more_clear_headers Server;
    more_set_headers "Server: NEHONIX/XNCP";

    # ------------------------------------------------------------------------
    # SSL/TLS Certificate Configuration
    # ------------------------------------------------------------------------

    # SSL certificate paths (managed by Let's Encrypt certbot)
    # fullchain.pem: Server certificate + intermediate certificates
    ssl_certificate         /etc/letsencrypt/live/{{DOMAIN_NAME}}/fullchain.pem;
    
    # privkey.pem: Private key (keep secure, never expose)
    ssl_certificate_key     /etc/letsencrypt/live/{{DOMAIN_NAME}}/privkey.pem;
    
    # chain.pem: Intermediate certificates for OCSP stapling
    ssl_trusted_certificate /etc/letsencrypt/live/{{DOMAIN_NAME}}/chain.pem;

    # ------------------------------------------------------------------------
    # SSL/TLS Protocol and Cipher Configuration
    # ------------------------------------------------------------------------

    # SSL protocols - Only modern, secure protocols
    # TLSv1.2: Required for compatibility (2008, still widely used)
    # TLSv1.3: Latest standard (2018, fastest and most secure)
    # Disabled: SSLv3, TLSv1, TLSv1.1 (vulnerable to attacks)
    ssl_protocols TLSv1.2 TLSv1.3;

    # SSL cipher suites - Mozilla "Modern" configuration
    # Prioritizes:
    #   - AEAD ciphers (GCM, CHACHA20-POLY1305) for authenticated encryption
    #   - ECDHE for Perfect Forward Secrecy (PFS)
    #   - AES-128 and AES-256 for strong encryption
    # This configuration ensures A+ rating on SSL Labs
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';
    
    # Let client choose cipher (better for modern browsers with TLSv1.3)
    # TLSv1.3 ignores this directive and always uses its own cipher selection
    ssl_prefer_server_ciphers off;

    # ------------------------------------------------------------------------
    # SSL Session Optimization
    # ------------------------------------------------------------------------

    # SSL session cache - stores session parameters for resumption
    # shared:SSL:10m = 10MB shared memory (stores ~40,000 sessions)
    # Session resumption reduces handshake overhead significantly
    ssl_session_cache   shared:SSL:10m;
    
    # Session timeout - how long cached sessions remain valid (1 day)
    ssl_session_timeout 1d;
    
    # Disable session tickets (potential security risk)
    # Session tickets can leak information if not rotated properly
    ssl_session_tickets off;

    # ------------------------------------------------------------------------
    # OCSP Stapling Configuration
    # ------------------------------------------------------------------------

    # Enable OCSP stapling - cache certificate revocation status
    # Reduces latency by avoiding client OCSP queries
    # Improves privacy by preventing OCSP server tracking
    ssl_stapling       on;
    ssl_stapling_verify on;
    
    # DNS resolvers for OCSP validation
    # Google DNS (8.8.8.8, 8.8.4.4) and Cloudflare DNS (1.1.1.1)
    # valid=300s = cache DNS responses for 5 minutes
    resolver 8.8.8.8 8.8.4.4 1.1.1.1 valid=300s;
    resolver_timeout 5s;

    # ------------------------------------------------------------------------
    # Security Headers (HTTPS)
    # ------------------------------------------------------------------------

    # HSTS - Force HTTPS for all future connections
    # max-age=63072000: 2 years (required for preload list)
    # includeSubDomains: Apply to all subdomains
    # preload: Allow inclusion in browser HSTS preload list
    # Submit to: https://hstspreload.org/
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" always;
    
    # X-Frame-Options - Prevent clickjacking attacks
    # SAMEORIGIN: Allow framing only from same origin
    add_header X-Frame-Options           "SAMEORIGIN"                               always;
    
    # X-Content-Type-Options - Prevent MIME-type sniffing
    # nosniff: Blocks MIME-type sniffing attacks
    add_header X-Content-Type-Options    "nosniff"                                  always;
    
    # X-XSS-Protection - Enable browser XSS filter (legacy browsers)
    # mode=block: Block page load instead of sanitizing
    add_header X-XSS-Protection          "1; mode=block"                            always;
    
    # Referrer-Policy - Control referrer information
    # strict-origin-when-cross-origin: Send full URL for same-origin, origin only for cross-origin HTTPS
    add_header Referrer-Policy           "strict-origin-when-cross-origin"          always;
    
    # Permissions-Policy - Restrict browser features
    # Disable potentially dangerous features: geolocation, microphone, camera
    add_header Permissions-Policy        "geolocation=(), microphone=(), camera=()" always;
    
    # X-Permitted-Cross-Domain-Policies - Restrict cross-domain policy files
    add_header X-Permitted-Cross-Domain-Policies "none"                             always;

    # ------------------------------------------------------------------------
    # Client Request Limits
    # ------------------------------------------------------------------------

    # Maximum allowed size for client request body (file uploads)
    client_max_body_size       {{MAX_BODY_SIZE}};
    
    # Buffer size for reading client request body
    client_body_buffer_size    128k;
    
    # Buffer size for reading client request headers
    client_header_buffer_size  1k;
    
    # Maximum number and size of buffers for large client headers
    large_client_header_buffers 4 16k;

    # ------------------------------------------------------------------------
    # Logging Configuration (HTTPS)
    # ------------------------------------------------------------------------

    # Access log - records all HTTPS requests
    access_log /var/log/nginx/{{DOMAIN_NAME}}_access.log combined;
    
    # Error log - records server errors and warnings
    error_log  /var/log/nginx/{{DOMAIN_NAME}}_error.log  warn;

    # ------------------------------------------------------------------------
    # Custom Error Pages (HTTPS)
    # ------------------------------------------------------------------------

    # Handle proxy/upstream errors only (502, 503, 504)
    # Backend handles its own 4xx errors
    error_page 502 503 504 /error.html;

    location = /error.html {
        root /var/www/html/errors;
        internal;
        default_type text/html;
    }

    # ------------------------------------------------------------------------
    # Backend Application Proxy (Main Location)
    # ------------------------------------------------------------------------

    location / {
        # Forward all requests to backend application server
        # Backend handles all application logic and 4xx/5xx responses
        proxy_pass         http://{{BACKEND_HOST}}:{{BACKEND_PORT}};
        
        # Use HTTP/1.1 for better keepalive support
        proxy_http_version 1.1;

        # WebSocket support - upgrade HTTP connection when requested
        # Required for real-time applications (Socket.IO, WebRTC, SSE)
        proxy_set_header Upgrade    $http_upgrade;
        proxy_set_header Connection "upgrade";

        # Standard proxy headers - preserve original request information
        # Host: Original hostname from client request
        proxy_set_header Host              $host;
        
        # X-Real-IP: Original client IP address
        proxy_set_header X-Real-IP         $remote_addr;
        
        # X-Forwarded-For: Chain of proxy IPs (for multiple proxies)
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        
        # X-Forwarded-Proto: Original protocol (https for this server block)
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # X-Forwarded-Host: Original hostname
        proxy_set_header X-Forwarded-Host  $server_name;
        
        # X-Forwarded-Port: Original port (443 for HTTPS)
        proxy_set_header X-Forwarded-Port  $server_port;

        # Proxy timeout settings - adjust based on application needs
        # Connect timeout: Time to establish connection with backend
        proxy_connect_timeout 90s;
        
        # Send timeout: Time to send request to backend
        proxy_send_timeout    90s;
        
        # Read timeout: Time to receive response from backend
        proxy_read_timeout    90s;

        # Proxy buffering settings for optimal performance
        # Buffering: Enable response buffering (improves performance)
        proxy_buffering          on;
        
        # Buffer size: Size of buffer for reading response headers
        proxy_buffer_size        4k;
        
        # Buffers: Number and size of buffers for reading response
        proxy_buffers            8 4k;
        
        # Busy buffers: Maximum size of buffers that can be busy sending
        proxy_busy_buffers_size  8k;
        
        # Temp file write size: Size of chunks written to temp files
        proxy_temp_file_write_size 64k;

        # Disable caching for dynamic content (WebSocket, API responses)
        # Cache bypass: Always fetch fresh data when connection is upgraded
        proxy_cache_bypass $http_upgrade;
        proxy_no_cache     $http_upgrade;

        # Error handling - intercept ONLY proxy-level errors (502/503/504)
        # Backend application handles its own 4xx/5xx JSON responses
        proxy_intercept_errors on;
        
        # Retry logic for upstream failures
        # Only retry on: connection errors, timeouts, invalid headers, 502/503/504
        proxy_next_upstream error timeout invalid_header http_502 http_503 http_504;
        
        # Maximum number of retry attempts
        proxy_next_upstream_tries   2;
        
        # Maximum time to spend retrying (30 seconds)
        proxy_next_upstream_timeout 30s;
    }

    # ------------------------------------------------------------------------
    # Static File Serving with Aggressive Caching
    # ------------------------------------------------------------------------

    # Serve common static assets directly from nginx (images, CSS, JS, fonts, videos)
    # This bypasses the backend application for better performance
    location ~* \.(jpg|jpeg|png|gif|ico|css|js|svg|woff|woff2|ttf|eot|mp4|webm|webp|avif)$ {
        root /var/www/html;
        
        # Custom error pages for missing static files
        error_page 404 /errors/404.html;
        error_page 301 /errors/301.html;
        
        # Return 404 if file doesn't exist locally (don't proxy to backend)
        try_files $uri =404;
        
        # Cache static files for 30 days in browser
        # 'public' allows caching by CDNs and proxies
        # 'immutable' tells browsers the file will never change
        expires 30d;
        add_header Cache-Control "public, immutable";
        
        # Disable access logging for static files (reduces I/O)
        access_log off;
    }

    # Error page handlers for static files
    location = /errors/404.html {
        root /var/www/html;
        internal;
        default_type text/html;
    }

    location = /errors/301.html {
        root /var/www/html;
        internal;
        default_type text/html;
    }

    # ------------------------------------------------------------------------
    # Security: Deny Access to Sensitive Files
    # ------------------------------------------------------------------------

    # Block access to hidden files and directories (starting with .)
    # Protects: .git, .env, .htaccess, .ssh, etc.
    location ~ /\. {
        deny all;
        access_log off;
        log_not_found off;
        return 404;
    }

    # Block access to backup and configuration files
    # Protects: database backups, config files, source files
    location ~* \.(bak|config|sql|fla|psd|ini|log|sh|inc|swp|dist|env|git)$ {
        deny all;
        access_log off;
        log_not_found off;
        return 404;
    }

    # ------------------------------------------------------------------------
    # Health Check Endpoints
    # ------------------------------------------------------------------------

    # Nginx-level health check - returns 200 OK with JSON status
    # Use this for load balancer health checks
    location /health {
        access_log off;
        add_header Content-Type application/json;
        add_header Cache-Control "no-cache, no-store, must-revalidate";
        return 200 '{"status":"healthy","server":"{{DOMAIN_NAME}}","ssl":true,"timestamp":"$time_iso8601"}';
    }

    # Backend readiness check - proxies to application health endpoint
    # Use this to verify backend application is ready to serve traffic
    location /ready {
        access_log off;
        
        # Forward to backend application's readiness endpoint
        proxy_pass http://{{BACKEND_HOST}}:{{BACKEND_PORT}}/ready;
        
        # Short timeouts for quick health check response
        proxy_connect_timeout 5s;
        proxy_read_timeout    5s;
        
        # Prevent caching of health check responses
        add_header Cache-Control "no-cache";
    }

    # ------------------------------------------------------------------------
    # SEO and Bot Management
    # ------------------------------------------------------------------------

    # Serve robots.txt without logging (reduces noise)
    location = /robots.txt {
        access_log off;
        log_not_found off;
    }
    
    # Serve favicon.ico without logging (reduces noise)
    location = /favicon.ico {
        access_log off;
        log_not_found off;
    }
}

# ============================================================================
# Configuration Notes
# ============================================================================
# 1. This configuration is optimized for production HTTPS environments
# 2. Achieves A+ rating on SSL Labs (https://www.ssllabs.com/ssltest/)
# 3. Certbot certificate renewal:
#    - Automatic: certbot renew (runs via cron/systemd timer)
#    - Manual: certbot certonly --webroot -w /var/www/letsencrypt -d {{DOMAIN_NAME}}
# 4. Test configuration: nginx -t
# 5. Reload nginx: systemctl reload nginx
# 6. Monitor logs: tail -f /var/log/nginx/{{DOMAIN_NAME}}_error.log
# 7. For HSTS preload submission: https://hstspreload.org/
# 8. Adjust timeouts based on application requirements (long-running requests)
# 9. Review security headers regularly for compliance with policies
# 10. Consider implementing Content-Security-Policy for XSS protection
# ============================================================================